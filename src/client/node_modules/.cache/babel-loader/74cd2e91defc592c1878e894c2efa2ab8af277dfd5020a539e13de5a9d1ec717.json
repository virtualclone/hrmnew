{"ast":null,"code":"import { required, validDateFormat, shouldNotExceedCharLength } from '@/core/util/validation/rules';\nimport { parseTime, parseDate, formatTime, formatDate, guessTimezone, setClockInterval, getStandardTimezone } from '@/core/util/helper/datefns';\nimport { promiseDebounce } from '@ohrm/oxd';\nimport useLocale from '@/core/util/composable/useLocale';\nimport { APIService } from '@ohrm/core/util/services/api.service';\nimport useDateFormat from '@/core/util/composable/useDateFormat';\nimport { reloadPage, navigate } from '@/core/util/helper/navigation';\nimport TimezoneDropdown from '@/orangehrmAttendancePlugin/components/TimezoneDropdown.vue';\nconst attendanceRecordModal = {\n  date: null,\n  time: null,\n  note: null,\n  timezone: null,\n  previousRecord: null\n};\nexport default {\n  name: 'RecordAttendance',\n  components: {\n    'timezone-dropdown': TimezoneDropdown\n  },\n  props: {\n    isEditable: {\n      type: Boolean,\n      default: false\n    },\n    isTimezoneEditable: {\n      type: Boolean,\n      default: false\n    },\n    attendanceRecordId: {\n      type: Number,\n      default: null\n    },\n    employeeId: {\n      type: Number,\n      default: null\n    },\n    date: {\n      type: String,\n      default: null\n    }\n  },\n  setup(props) {\n    const apiPath = props.employeeId ? `/api/v2/attendance/employees/${props.employeeId}/records` : '/api/v2/attendance/records';\n    const http = new APIService(window.appGlobal.baseUrl, apiPath);\n    const {\n      jsDateFormat,\n      userDateFormat,\n      timeFormat,\n      jsTimeFormat\n    } = useDateFormat();\n    const {\n      locale\n    } = useLocale();\n    return {\n      http,\n      locale,\n      timeFormat,\n      jsTimeFormat,\n      jsDateFormat,\n      userDateFormat\n    };\n  },\n  data() {\n    return {\n      isLoading: false,\n      attendanceRecord: {\n        ...attendanceRecordModal\n      },\n      rules: {\n        date: [required, validDateFormat(this.userDateFormat), promiseDebounce(this.validateDate, 500)],\n        time: [required, promiseDebounce(this.validateDate, 500)],\n        note: [shouldNotExceedCharLength(250)]\n      },\n      previousRecordTimezone: null\n    };\n  },\n  computed: {\n    previousAttendanceRecordDate() {\n      if (!this.attendanceRecord?.previousRecord) return null;\n      return formatDate(parseDate(this.attendanceRecord.previousRecord.userDate), this.jsDateFormat, {\n        locale: this.locale\n      });\n    },\n    previousAttendanceRecordTime() {\n      if (!this.attendanceRecord?.previousRecord) return null;\n      return formatTime(parseTime(this.attendanceRecord.previousRecord.userTime, this.timeFormat), this.jsTimeFormat);\n    }\n  },\n  beforeMount() {\n    this.isLoading = true;\n    // set default timezone\n    if (this.isTimezoneEditable) {\n      const tz = guessTimezone();\n      this.attendanceRecord.timezone = {\n        id: tz.name,\n        label: tz.label,\n        _name: tz.name,\n        _offset: tz.offset\n      };\n    }\n\n    // fetch and set attendance record on initial load\n    this.setCurrentDateTime().then(() => {\n      // then set record date/time every minute\n      !this.date && !this.isEditable && setClockInterval(this.setCurrentDateTime, 60000);\n      let url = '/api/v2/attendance/records/latest';\n      if (this.employeeId) {\n        url = `/api/v2/attendance/records/latest?empNumber=${this.employeeId}`;\n      }\n      return this.attendanceRecordId ? this.http.request({\n        method: 'GET',\n        url\n      }) : null;\n    }).then(response => {\n      if (response) {\n        const {\n          data\n        } = response.data;\n        this.attendanceRecord.previousRecord = data.punchIn;\n      }\n    }).then(() => {\n      this.previousRecordTimezone = getStandardTimezone(this.attendanceRecord.previousRecord?.offset);\n    }).finally(() => {\n      this.isLoading = false;\n    });\n  },\n  methods: {\n    onSave() {\n      this.isLoading = true;\n      const timezone = guessTimezone();\n      this.http.request({\n        method: this.attendanceRecordId ? 'PUT' : 'POST',\n        data: {\n          date: this.attendanceRecord.date,\n          time: this.attendanceRecord.time,\n          note: this.attendanceRecord.note,\n          timezoneOffset: this.attendanceRecord.timezone?._offset ?? timezone.offset,\n          timezoneName: this.attendanceRecord.timezone?.id ?? timezone.name\n        }\n      }).then(() => {\n        return this.$toast.saveSuccess();\n      }).then(() => {\n        this.employeeId ? navigate('/attendance/viewAttendanceRecord', undefined, {\n          employeeId: this.employeeId,\n          date: this.date\n        }) : reloadPage();\n      });\n    },\n    setCurrentDateTime() {\n      return new Promise((resolve, reject) => {\n        this.http.request({\n          method: 'GET',\n          url: '/api/v2/attendance/current-datetime'\n        }).then(res => {\n          const {\n            utcDate,\n            utcTime\n          } = res.data.data;\n          const currentDate = parseDate(`${utcDate} ${utcTime} +00:00`, 'yyyy-MM-dd HH:mm xxx');\n          this.attendanceRecord.date = this.date ?? formatDate(currentDate, 'yyyy-MM-dd');\n          this.attendanceRecord.time = formatDate(currentDate, 'HH:mm');\n          resolve();\n        }).catch(error => reject(error));\n      });\n    },\n    validateDate() {\n      if (!this.attendanceRecord.date || !this.attendanceRecord.time) {\n        return true;\n      }\n      if (parseDate(this.attendanceRecord.date) === null) {\n        return true;\n      }\n      const tzOffset = new Date().getTimezoneOffset() / 60 * -1;\n      return new Promise(resolve => {\n        this.http.request({\n          method: 'GET',\n          url: `/api/v2/attendance/${this.attendanceRecordId ? 'punch-out' : 'punch-in'}/overlaps`,\n          params: {\n            date: this.attendanceRecord.date,\n            time: this.attendanceRecord.time,\n            timezoneOffset: this.attendanceRecord.timezone?._offset ?? tzOffset,\n            empNumber: this.employeeId\n          },\n          // Prevent triggering response interceptor on 400\n          validateStatus: status => {\n            return status >= 200 && status < 300 || status == 400;\n          }\n        }).then(res => {\n          const {\n            data,\n            error\n          } = res.data;\n          if (error) {\n            return resolve(error.message);\n          }\n          return data.valid === true ? resolve(true) : resolve(this.$t('attendance.overlapping_records_found'));\n        });\n      });\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}