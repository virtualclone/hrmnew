{"ast":null,"code":"import { required, validDateFormat, shouldNotExceedCharLength, endDateShouldBeAfterStartDate } from '@/core/util/validation/rules';\nimport { yearRange } from '@ohrm/core/util/helper/year-range';\nimport { diffInDays } from '@ohrm/core/util/helper/datefns';\nimport { APIService } from '@ohrm/core/util/services/api.service';\nimport LeaveDurationInput from '@/orangehrmLeavePlugin/components/LeaveDurationInput';\nimport LeaveBalance from '@/orangehrmLeavePlugin/components/LeaveBalance';\nimport LeaveConflict from '@/orangehrmLeavePlugin/components/LeaveConflict';\nimport useLeaveValidators from '@/orangehrmLeavePlugin/util/composable/useLeaveValidators';\nimport useForm from '@ohrm/core/util/composable/useForm';\nimport useDateFormat from '@/core/util/composable/useDateFormat';\nconst leaveModel = {\n  type: null,\n  fromDate: null,\n  toDate: null,\n  comment: '',\n  partialOptions: null,\n  duration: {\n    type: null,\n    fromTime: null,\n    toTime: null\n  },\n  endDuration: {\n    type: null,\n    fromTime: null,\n    toTime: null\n  }\n};\nexport default {\n  name: 'LeaveApply',\n  components: {\n    'leave-duration-input': LeaveDurationInput,\n    'leave-balance': LeaveBalance,\n    'leave-conflict': LeaveConflict\n  },\n  props: {\n    workShift: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  setup() {\n    const http = new APIService(window.appGlobal.baseUrl, '/api/v2/leave/leave-requests');\n    const {\n      serializeBody,\n      validateOverlapLeaves\n    } = useLeaveValidators(http);\n    const {\n      formRef,\n      reset\n    } = useForm();\n    const {\n      userDateFormat\n    } = useDateFormat();\n    return {\n      http,\n      reset,\n      formRef,\n      serializeBody,\n      userDateFormat,\n      validateOverlapLeaves\n    };\n  },\n  data() {\n    return {\n      isLoading: false,\n      leave: {\n        ...leaveModel\n      },\n      rules: {\n        type: [required],\n        fromDate: [required, validDateFormat(this.userDateFormat)],\n        toDate: [required, validDateFormat(this.userDateFormat), endDateShouldBeAfterStartDate(() => this.leave.fromDate, this.$t('general.to_date_should_be_after_from_date'), {\n          allowSameDate: true\n        })],\n        comment: [shouldNotExceedCharLength(250)]\n      },\n      partialOptions: [{\n        id: 1,\n        label: this.$t('leave.all_days'),\n        key: 'all'\n      }, {\n        id: 2,\n        label: this.$t('leave.start_day_only'),\n        key: 'start'\n      }, {\n        id: 3,\n        label: this.$t('leave.end_day_only'),\n        key: 'end'\n      }, {\n        id: 4,\n        label: this.$t('leave.start_and_end_day'),\n        key: 'start_end'\n      }],\n      showLeaveConflict: false,\n      isWorkShiftExceeded: false,\n      leaveConflictData: null,\n      yearsArray: [...yearRange()],\n      leaveTypes: []\n    };\n  },\n  computed: {\n    appliedLeaveDuration() {\n      return diffInDays(this.leave.fromDate, this.leave.toDate);\n    },\n    showDuration() {\n      const id = this.leave.partialOptions?.id;\n      return id && id === 1;\n    },\n    showStartDay() {\n      const id = this.leave.partialOptions?.id;\n      return id && (id === 2 || id === 4);\n    },\n    showEndDay() {\n      const id = this.leave.partialOptions?.id;\n      return id && (id === 3 || id === 4);\n    }\n  },\n  watch: {\n    appliedLeaveDuration: function (duration) {\n      if (duration === 1) {\n        this.leave.duration.type = {\n          id: 1,\n          label: 'Full Day',\n          key: 'full_day'\n        };\n      } else {\n        this.leave.duration.type = null;\n      }\n    },\n    'leave.fromDate': function (fromDate) {\n      if (!fromDate || this.leave.toDate) return;\n      this.leave.toDate = fromDate;\n    }\n  },\n  beforeMount() {\n    this.isLoading = true;\n    this.http.request({\n      method: 'GET',\n      url: '/api/v2/leave/leave-types/eligible'\n    }).then(response => {\n      const {\n        data\n      } = response.data;\n      console.log(response.data);\n      this.leaveTypes = data.map(item => {\n        return {\n          id: item.id,\n          label: item.name\n        };\n      });\n    }).finally(() => {\n      this.isLoading = false;\n    });\n  },\n  methods: {\n    onSave() {\n      this.isLoading = true;\n      this.showLeaveConflict = false;\n      this.leaveConflictData = null;\n      this.validateOverlapLeaves(this.leave).then(({\n        isConflict,\n        isOverWorkshift,\n        data\n      }) => {\n        if (isConflict) {\n          this.leaveConflictData = data;\n          this.showLeaveConflict = true;\n          this.isWorkShiftExceeded = isOverWorkshift;\n          return Promise.reject();\n        }\n        return this.http.create(this.serializeBody(this.leave));\n      }).then(() => {\n        this.$toast.saveSuccess();\n        this.reset();\n      }).catch(() => {\n        this.showLeaveConflict && this.$toast.warn({\n          title: this.$t('general.warning'),\n          message: this.$t('leave.failed_to_submit')\n        });\n      }).finally(() => {\n        this.isLoading = false;\n      });\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}